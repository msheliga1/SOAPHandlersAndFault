Michael Sheliga - 6.4.18 - readme.md file for DWPmv30SoapHandlers Eclipse Java Project.

Purpose: The purpose of this project is to demonstrate SOAP Handling techniques and SOAP Faults. 

Highlights: Handler chains are set up using both an xml file and through java code.  The client side 
handler chain is changed dynamically as the program executes.  Some handlers are set up to run for all 
methods while others are targeted to specific routines.  Some handlers run for both inbound and 
outbound messages while others are only one way. SOAP faults are generated by both web methods 
using a variety of exception types, as well as by the soap handlers.  Finally, the code includes 
some pretty complex streams, especially in the BornHandler, as well as an involved soap message 
pretty print routine.

Execution: To execute this project in Eclipse start a server, such as Tomcat, with this project attached 
to the server.  Type http://localhost:8080/DWPmv30SoapHandlers/handle?wsdl to see the wsdl and verify 
the server has properly started this process. Then open a project explorer and find the handleClient->SoapHandlerClient.java
file.  Run this file as a java application.  It may help to have multiple consoles open as both server side and 
client side output will be displayed. 

Handler Details
----------------------------------------------------------------------------------------------

Handler Chain Implementation Methodology:
For variety handler chains are implement in an xml file and in java code. 
The server implements a handler chain in an xml file. The client implements two handler chains in java and dynamically switches between them. 

Handler Types: 
A total of 7 handlers have been implemented, 4 for the client side and 3 for the server side.  Below is a summary.

Client Side Handlers
Age Handler       - Logical - Outbound - Converts negative ages to positive.              - For GetOldestFamily method.
Parent Handler    - Logical - Outbound - Increases parent age if less than a child's age. - For GetOldestFamily method.
Date Handler      - SOAP    - Outbound - Inserts date (epoch seconds) into soap header.   - For all methods.
PrintSoap Handler - SOAP    - In + Out - Pretty prints soap message                       - For all methods.

Server Side Handlers
MethodName Handler - SOAP    - In + Out - Prints soap message's method name.  - For all methods.
Timeout Handler    - SOAP    - Inbound  - Randomly generates a timeout fault. - For sayHi method.
Marriage Handler   - Logical - In + Out - Prints info about itself            - For all methods.

All handler methods (handleMessage, handleFault, close and gHeaders) also print a one line summary 
as they begin execution on both the inbound and outbound side. 

Fault Details
-------------------------------------

Fault Implementation Methodology:
For variety faults are thrown from both the handlers as well as the web methods. In particular the getPersonAge 
web method throws four different types of "too old" faults.  

Fault Types: 

Web Method Exceptions:
These include a runtime exception (NPE), a standard checked exception (IOException), 
a derived checked exception without a detail field or getFaultInfo method, and 
a derived checked exception with a detail field and a getFaultInfo method. 

Handler Exceptions:
This includes a server side timeoutHandler throwing a SOAPFaultException(fault) with 2 entry details.

Client Execution
------------------------------------------

Generally: 
As the client executes it calls various web methods.  Each web method has various handlers attached.  
Of these the client side PrintSoap Handler is perhaps the most important because it pretty prints the 
soap request message right before the server sends it, as well as the soap response message right after 
it is returned. The server side handlers has a similar method but for brevity it only prints the 
method name. These 2 handlers greatly help to understand the soap messages as they are being transferred.

Similarly, all handlers have each of their methods print a brief summary as they begin execution. For example, 
"SLH1: MarriageHandler: handleFault ==>" would indicate that the Server Logical Handler #1 (SLH1) is being executed. 
The Handler's name is MarriageHandle and the method name is handleFault.  Finally "==>" indicates this is an 
outbound message, while "<==" indicates an inbound message. 

In Order:
The client begins by setting up the client handlers.  Only the DateHandler and AddSoapHandler are originally in the client 
side chain.  The server side always has the MethodNameHandler, TimeoutHandler and MarriageHandlers. 

First the sayHi method is called. The DateHandler first adds a date (in epoch second format) to the soap header.  
Next the PrintSoapHandler prints the entire message and the inserted date can be viewed. The message is then sent 
to the server side.  First the MethodName handler prints the method's name.  Next the timeoutHandler is reached and it 
randomly generates a SOAP fault using:

				SOAPFault fault = body.addFault();
				fault.setFaultString("Timeout Fault");
				Detail detail = fault.addDetail();
				QName qName = new QName("tns", "TimeoutHandler");
				DetailEntry entry = detail.addDetailEntry(qName);
				entry.addTextNode("Timeout Detail Line1");
				DetailEntry entry2 = detail.addDetailEntry(qName);
				entry2.addTextNode("Randomly generated soap fault.");
				throw new SOAPFaultException(fault);

If this fault is randomly generated the system proceeds to the outbound server handlers, but only for the completed 
incoming handlers (the MethodNameHandler handleFault routine in this specific case.) When this simulated timeout fault is received by the client it executes the handleFault methods for all client side handlers and then transfers execution to 
the client side program, which resubmits the same request up to 5 times. Hence, the first part of the client output will consist of 0 to 5 sayHi requests followed by timeout faults and/or a sayHiResponse. The final server side handler, the 
logical marriageHandler, will be run only when a timeout fault is not randomly generated.

Second the getPersonAge method is called using an age that will cause a web method fault. The client processes this 
fault, decreases the age by 5 years, and reissues the request.  Due to the code in the getPersonAge method, as shown 
below, 4 different types of faults will be generated. (1) a runtime NPE exception, (2) a standard checked exception, 
(3) a derived checked exception without a getFaultInfo method, and (4) a dervied checked exception with a details field 
and a getFaultInfo method.  The soap generated by each type of fault can then be inspected in the client side output. Note that the unchecked NullPointerException will generate a stack trace in the server side output.  This behavior is allowed since the purpose of the program is to understand what happens when exceptions of various types are generated.

		if (age > 140) throw new NullPointerException("Too old NPE.");
		if (age > 135) throw new IOException("Too old IOException.");
		if (age > 130) throw new BasicCheckedException("Too old BasicChecked");
		if (age > 125) throw new FaultCheckedException("Too old reason", "Fault Detail");
		return p1.getAge();

Third, a series of web methods are called including one to get a list of families. It is much easier to set up such 
a list on the server side since it can access complex constructors with many arguments and other routines, 
while the client side is limited to the empty constructor and setting one value at a time through the client artifacts.

Fourth, the client side handler chain is modified.  This requires both setting a new chain and getting a new port 
after the chain has been updated, as shown below. 

		service.setHandlerResolver(new GOFHandlersResolver());
		HandlerWS port = service.getHandlerWSImplPort();
		System.out.println(port.getOldestFamily(clans));
		
The web method getOldestFamily is now called.  With the new handler chain people's ages (such as Tom's) are now corrected 
if they are less than zero.  Similarly the ages of parent's are updated if they are younger than any of their 
children.  Via the PrintSoapHandler the modified ages can be viewed as the SOAP message is transfered from the 
client to the server. 

Other Highlights:
---------------------------------
Streams:
The code includes some pretty complex streams, especially in the AgeHandler and 
the BornHandler routines. For example:

		List<Family> familyList2 = gof.getArg0();
		List<Person> parentList = familyList2.stream()
			.map(fam->fam.getParents())
			.flatMap(p->p.stream())
			.collect(Collectors.toList());
		List<Family> familyList = gof.getArg0();
		List<Person> kidList = familyList.stream()
			.map(fam->fam.getChildren())
			.flatMap(p->p.stream())
			.collect(Collectors.toList());
		// Combine parent, children lists, flatMap, filter, update
		Arrays.asList(parentList, kidList).stream()
			.flatMap(p->p.stream())
			.filter(p->p.getAge() < 0)          // main filter
			.forEach(p->p.setAge(-p.getAge())); // convert negatives to positives

SAAJ Processing:
An involved soap message pretty print routine (which could be implemented 
much more concisely using a DOM transform or inherited methods) is a 
good exercise in using SAAJ and DOM. 
